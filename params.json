{"name":"Rococo","tagline":"Javascript Microframework","body":"### Welcome\r\n\r\nRococo is a Micro Framework to create elegant and robust Javascript Applications.\r\n\r\n\tPerfection is achieved, \r\n\tnot when there is nothing more to add, \r\n\tbut when there is nothing left to take away.\r\n        -- Antoine de Saint-Exupery\r\n\r\nRococo works with a strict subset of Javascript (informally we call this BlackScript). BlackScript is like Javascript but has no:\r\n\r\n* new keyword\r\n* prototypes\r\n* this keyword\r\n* native constructors\r\n* __proto__\r\n* object.create\r\n* labels\r\n* with keyword\r\n\r\nWe choose to work with BlackScript instead of Javascript because:\r\n\r\n* we prefer a small, clean language without half-baked features\r\n* a language that works in all browsers even the oldest ones (unlike object.create or __proto__)\r\n\r\n### Object Oriented Programming in BlackScript\r\n\r\nTo understand Rococo, you need to understand BlackScript first. Object oriented programming in BlackScript is really simple. We only use literals.\r\n\r\nA class is a literal object that produces other objects and is defined in a class namespace like this:\r\n\r\n     UI.classes.Machine {\r\n           createNew: function(bundle) {\r\n                 var protect = bundle || {};\r\n                 //protected property\r\n                 protect.coin = false;\r\n                 var obj = {};\r\n                 obj.insertCoin = function(coin) {\r\n                      protect.coin = true;\r\n                 }\r\n                 return obj;\r\n           }\r\n     }\r\n\r\n     UI.classes.CoffeeMachine = {\r\n           createNew: function(bundle) {\r\n                 var protect = bundle || {};\r\n                 //inherit from machine\r\n                 var obj = UI.classes.Machine.createNew(protect); \r\n                 obj.makeCoffee = function() {\r\n                      if (!protect.coin) return 'insert coin!';\r\n                      protect.coin = false;\r\n                      return 'espresso';\r\n                 }\r\n                 return obj;\r\n           }\r\n     }\r\n\r\n\r\nYou can use this class like this:\r\n\r\n     var c = UI.classes.CoffeeMachine.createNew();\r\n     c.insertCoin(1);\r\n     c.makeCoffee(); //returns 'espresso'\r\n\r\n\r\n### Using Rococo\r\n\r\nRococo helps you to structure your BlackScript application. A Rococo application consists of three parts: HTML, components and delegates or helpers.\r\n\r\n* HTML is where you store the markup \r\n* Components is where you store reusable code\r\n* Delegates and helpers are where you store custom behaviour\r\n\r\nRococo separates these three and re-connects them to form an application.\r\n\r\n### Your first component\r\n\r\nRococo thinks in components. You write a Rococo application by defining (or reusing) components. A component manages an HTML snippet. For instance consider the following button:\r\n\r\n     <button class=\"awake\" data-post=\"/store\" data-awake=\"ActionButton\" >SAVE DOCUMENT</button>\r\n\r\nHere we have the HTML for a save button. We would like to have a general button that performs a server call and updates the label afterwards. This is our 'generic' component. We can define this component like this:\r\n\r\n     UI.components.ActionButton = {\r\n            createNew: function() {\r\n                   var obj = {};\r\n                   obj.init = function() {\r\n                         $(this).on('click', function(e){\r\n                              e.preventDefault();\r\n                              var url = obj.$node.attr('data-post');\r\n                              var data = $.serialize(obj.$node.parents('form'));\r\n                              $.post(url, data, function(){\r\n                                   obj.$node.html('SAVED!');\r\n                              });\r\n                         });\r\n                   }\r\n                   return obj;\r\n            }\r\n     }\r\n\r\n### Delegates\r\n\r\nWhile this button will work just fine, it would be nice if we could change the default behaviour of the button after posting the data. This would allow us to use this buttons in projects that require slightly different ActionButton behaviour. To do so, we add a delegate like this:\r\n\r\n`<button class=\"awake\" data-post=\"/store\" data-awake=\"ActionButton\" data-delegate=\"controller\" >SAVE DOCUMENT</button>`\r\n\r\nAnd we define our delegate:\r\n\r\n     UI.classes.Controller = {\r\n            createNew: function() {\r\n                   var obj = {};\r\n                   obj.serverDidRespond = function(resp) {\r\n                        return JSON.parse(resp).message;\r\n                   }\r\n                   return obj;\r\n            }\r\n     }\r\n\r\n     UI.instances.controller = UI.classes.Controller.createNew();\r\n\r\nAnd we change the component to:\r\n\r\n      $.post(url, data, function(){\r\n           obj.$node.html( obj.delegate.serverDidRespond() );\r\n      });\r\n\r\nNow we can specify any behaviour for our ActionButton! But even better the connection between the component and delegate has been specified in the HTML, the classes are loosely coupled and easy to test.\r\n\r\n### Connecting nodes\r\n\r\nMost of the time, a component consists of a single DOM node containing several child nodes. Together these nodes form the component DOM available in your component object property obj.$node.\r\n\r\nSometimes however you may have several DOM nodes forming a component together. For instance if you have a sortable table component and a list of filters in the sidebar, or a video component with a separate remote control formed by a set of additional DOM nodes. Rococo allows you to easily connect these nodes.\r\n\r\n\r\n    <div class=\"awakable\" id=\"cinema\" data-awake=\"VideoPlayer\"></div>\r\n    <div class=\"connected\" data-belongsto=\"cinema\"><a>PLAY</a></div>\r\n\r\nIn this example we connect a player control to its component. Note that we use a class 'connected' to mark the DOM node as being connected to another DOM node. Then, we specify the owning DOM node by its ID in the data-belongsto property.\r\n\r\nBoth DOM nodes will now be available in obj.$nodes\r\n\r\n### Factories\r\n\r\nInstead of using a delegate object you can also specify a delegate class. Using the\r\n\r\n     data-factory=\"MyDelegateClass\"\r\n\r\n\r\nYou can specify which delegate class should be used to create the delegate instance. Rococo will now function as a factory and create an instance of MyDelegateClass and connect this delegate object to your component instance.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}